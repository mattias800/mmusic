# AI Agent Development Guidelines for mmusic Project

This document provides a central point for guidelines for AI agents assisting with the development of the mmusic project.

Guidelines are split by project area:

- **Backend (MusicGQL):** [./MusicGQL/AGENTS.md](./MusicGQL/AGENTS.md)
- **Frontend (Web):** [./Web/AGENTS.md](./Web/AGENTS.md) (which in turn links to [./Web/.junie/guidelines.md](./Web/.junie/guidelines.md))

Please refer to the specific guidelines relevant to the part of the codebase you are working on.

## 1. Understanding the Project

- **Familiarize Yourself:** Before making changes, try to understand the relevant parts of the project structure, including both the C# backend (ASP.NET Core, HotChocolate for GraphQL) and the TypeScript frontend (React, Vite, urql).
- **Ask Questions:** If the user's request is unclear or ambiguous, ask for clarification. It's better to ask than to make incorrect assumptions.

## 2. Code Style and Conventions

### General
- **Consistency:** Strive to maintain consistency with the existing codebase in terms of style, naming conventions, and architectural patterns.
- **Readability:** Write clear, concise, and well-documented code where necessary. Comment on non-obvious logic.
- **Modularity:** Create small, focused functions and components where appropriate.

### Frontend (React & TypeScript)
- **Functional Components:** Always use functional React components with Hooks.
- **TypeScript:** Utilize TypeScript's features for strong typing. Define interfaces or types for props, state, and API payloads.
- **Imports:** Use absolute paths with the `@/` alias (e.g., `@/features/...`) for imports within the `Web/src` directory.
- **File Naming:** Use PascalCase for component files (e.g., `MyComponent.tsx`).
- **Styling:** (User to specify preferred styling approach if any - e.g., CSS Modules, styled-components, Tailwind CSS). For now, inline styles are sometimes used for expediency, but consider maintainability.

### Backend (C# & ASP.NET Core)
- **Naming Conventions:** Follow standard C# naming conventions (e.g., PascalCase for classes, methods, properties).
- **Async/Await:** Use `async` and `await` for I/O-bound operations.
- **Dependency Injection:** Utilize ASP.NET Core's built-in dependency injection.
- **LINQ:** Use LINQ for data manipulation where appropriate.

## 3. GraphQL Usage (Frontend & Backend)

### Frontend (urql)
- **Queries/Mutations:**
    - Define GraphQL operations (queries, mutations, fragments) using the `graphql` tag from `@/gql` or preferably use the pre-compiled `...Document` constants generated by `graphql-codegen` (e.g., `import { MyQueryDocument } from '@/gql/graphql';`).
    - Place GraphQL operations in the relevant feature/component file or a dedicated `*.gql.ts` file if they become too numerous.
- **Generated Types:** Always use the TypeScript types generated by `graphql-codegen` (from `@/gql/graphql`) for query/mutation results and variables.
    - Example: `useQuery<MyQuery, MyQueryVariables>({ query: MyQueryDocument, ... });`
- **Colocation:** Keep GraphQL operations co-located with the components that use them, or within the same feature module.

### Backend (HotChocolate)
- **Schema-First vs. Code-First:** The project uses a code-first approach with HotChocolate. GraphQL types are generated from C# classes.
- **Naming:** HotChocolate typically converts C# method names to camelCase for GraphQL field names. Use `[GraphQLName("explicitName")]` if a different GraphQL field name is desired.
- **Type Extensions:** Extend the root `Query`, `Mutation`, or `Subscription` types by creating classes that use `[ExtendObjectType(typeof(Query))]`.
- **Registration:** Ensure new Query/Mutation/Subscription type extensions are registered in `Program.cs` (e.g., `.AddTypeExtension<MyNewQueries>()`).

#### GraphQL Mutation Pattern (Mandatory)

- **Single input object parameter**: Every mutation must accept exactly one argument named `input` of an input record/class specific to that mutation.
  - Example: `public Task<SignInResult> SignIn(SignInInput input, ...)`.
- **Naming convention (use the SignIn pattern):**
  - **Class**: `OperationNameMutation` (e.g., `SignInMutation`, `AddTrackToPlaylistMutation`).
  - **Method**: `OperationName` (e.g., `SignIn`, `AddTrackToPlaylist`).
  - **Input**: `OperationNameInput` (e.g., `SignInInput`).
  - **Union Result**: `OperationNameResult` with `[UnionType]`.
  - **Success Record**: `OperationNameSuccess`.
  - **Other Result Records**: `OperationNameError` or other specific variants as needed.
- **One file per mutation**: Each mutation must live in its own `.cs` file under its feature's `Mutations/` folder.
- **Example (reference pattern from `SignInMutation`):**

```csharp
[ExtendObjectType(typeof(Mutation))]
public class SignInMutation
{
    public async Task<SignInResult> SignIn(SignInInput input, [Service] ...)
    {
        // ... implementation ...
        return new SignInSuccess(new(user));
    }
}

public record SignInInput(string Username, string Password);

[UnionType]
public abstract record SignInResult;
public record SignInSuccess(User User) : SignInResult;
public record SignInError(string Message) : SignInResult;
```

- When converting existing mutations, replace multiple scalar parameters with a single `OperationNameInput` parameter and update all references accordingly (backend and frontend). See the "Recent Lessons" section for additional context.

#### Mutation Success Payload Rule

- **Success unions must return the modified entity (or entities)**: On success, include the domain object that was changed so clients can update caches without refetching.
  - Examples:
    - Add/remove/move track in playlist → return the updated `Playlist`.
    - Create/rename/delete playlist → return `Playlist` (or `deletedPlaylistId` for deletions).
    - Refresh artist metadata → return the updated `Artist`.
    - Import Spotify playlist → return the created `Playlist`.
    - Refresh/rescan/redownload release → return the updated `Release`.
  - Returning multiple related entities is allowed but should be avoided when one is a parent/child of the other.
  - For destructive actions (e.g., delete), return the parent entity that changed or at minimum the identifier(s) of what was deleted so the client can reconcile state.

#### GraphQL Type Naming for Mutations (No Nested Records)

- Do NOT nest success/error record types inside the union record for mutations. Nested records inherit the parent type name in C#, which leads to confusing or duplicate GraphQL type names. Always declare each mutation result record at the top level with clear names:
  - Good:
    - `public abstract record RenamePlaylistResult;`
    - `public record RenamePlaylistSuccess(Playlist Playlist) : RenamePlaylistResult;`
    - `public record RenamePlaylistError(string Message) : RenamePlaylistResult;`
  - Avoid:
    - `public abstract record RenamePlaylistResult { public record Success(...) : RenamePlaylistResult; }`
  - Rationale: GraphQL uses the C# type name (or explicit `[UnionType("...")]`) for schema names. Nested types often produce ambiguous or undesirable names and complicate registration.

## 4. State Management (Frontend)

- **Local State:** Use `useState` for component-local state.
- **Shared State:**
    - For simple shared state between a few components, consider prop drilling or React Context (`useContext`).
    - For more complex global state, (User to specify if a global state manager like Zustand, Redux, or Jotai is preferred or already in use). `urql` itself provides client-side caching for GraphQL data.
- **Derived State:** Use `useMemo` to memoize expensive calculations or derived data. `useCallback` for memoizing functions passed as props.

## 5. Error Handling

### Frontend
- **API Errors:** Catch errors from `urql` hooks (`result.error`) and display user-friendly messages or fallback UI.
- **Component Errors:** Use error boundaries for larger sections of the UI if applicable.
- **Input Validation:** Provide clear validation messages for user inputs.

### Backend
- **Exceptions:** Handle exceptions gracefully. Return appropriate GraphQL errors to the client.
- **Validation:** Use FluentValidation or similar for input DTOs in mutations/queries if complex validation is needed.

## 6. Backend Development

- **Migrations:** When changing database models (entities in `MusicGQL/Db/Postgres/Models/`), create new Entity Framework migrations:
    - `cd MusicGQL`
    - `dotnet ef migrations add MigrationName`
    - `dotnet ef database update`
- **Services:** Encapsulate business logic and interactions with external services or the database within service classes.
- **Event Sourcing:** The playlist database is event-sourced. Be mindful of existing events and create new ones as needed (`MusicGQL/Db/Postgres/Models/Events/`).

## 7. Tooling and Workflow

- **GraphQL Codegen:** After backend GraphQL schema changes, run `bun run types` in the `Web` directory to regenerate frontend types and documents. The backend server (`MusicGQL`) must be running and accessible (usually on `http://localhost:5095/graphql` as per `Web/codegen.ts`) for this to succeed.
- **Building & Running:**
    - **Backend:** `cd MusicGQL && dotnet build && dotnet run`
    - **Frontend:** `cd Web && bun install && bun dev`
- **Linting/Formatting:** (User to specify linters/formatters like ESLint, Prettier, and how to run them). Assume they are run automatically or via IDE integrations.

## 8. Testing

- (User to specify testing strategy, frameworks like Jest, Vitest, React Testing Library, xUnit, NUnit, and where tests are located).
- Strive to write testable code.

## 9. Commit Messages

- (User to specify preferred commit message format, e.g., Conventional Commits).
- As a general guideline: Write clear and concise commit messages that explain the "what" and "why" of the change.

## 10. Communication with User

- **Proactive Updates:** Keep the user informed about the plan, progress, and any issues encountered.
- **Confirmation:** Before making significant changes or if unsure, confirm the approach with the user.
- **Tool Usage Explanation:** Briefly explain why a tool is being used if it's not obvious.
- **Summaries:** Provide summaries of changes made, especially for larger tasks.

## 11. Recent Lessons (Do Not Repeat)

- Always convert new GraphQL mutations to use a single input object parameter, following the SignInMutation pattern.
  - Example: prefer `refreshRelease(input: RefreshReleaseInput!)` over `refreshRelease(artistId: String!, releaseFolderName: String!)`.
  - Backend: method signature should accept a C# input record/class, e.g., `public Task<RefreshReleaseResult> RefreshRelease(RefreshReleaseInput input, ...)`.
  - Frontend: call with `refreshRelease({ input: { artistId, releaseFolderName }})` and regenerate types (`bun run types:once`).

- After creating new GraphQL type extensions, register them in Program.cs.
  - Add `.AddTypeExtension<YourMutationClass>()` and explicitly add result types if needed.
  - Missing registration causes the operation to be absent from the runtime schema.

- Frontend GraphQL documents (queries, mutations, fragments) must be defined at module scope, not inside React component bodies.
  - Do not redeclare the same `graphql` document inside a component; define it once at the top of the file and reuse it with hooks.
  - This avoids recreating documents on each render and ensures stable document identities for caching/codegen.
  - After any schema or document change, regenerate types (`cd Web && bun run types`).

- When adding potentially destructive actions in the UI (e.g., deleting audio files), implement a confirmation dialog and extract it into a dedicated component for reuse and clarity.
  - Place components under a feature-appropriate folder (e.g., `Web/src/features/album/components/ConfirmDeleteReleaseAudioDialog.tsx`).

- When modifying release metadata or audio references, update only the affected release in the cache instead of rebuilding the entire cache.
  - Use `ServerLibraryCache.UpdateReleaseFromJsonAsync(artistId, releaseFolderName)` and preserve track-level statuses.

This is a starting point. Please feel free to update and expand these guidelines as the project evolves! 
