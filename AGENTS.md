# AI Agent Development Guidelines for mmusic Project

This document provides a central point for guidelines for AI agents assisting with the development of the mmusic project.

Guidelines are split by project area:

- **Backend (MusicGQL):** [./MusicGQL/AGENTS.md](./MusicGQL/AGENTS.md)
- **Frontend (Web):** [./Web/AGENTS.md](./Web/AGENTS.md) (which in turn links to [./Web/.junie/guidelines.md](./Web/.junie/guidelines.md))

Please refer to the specific guidelines relevant to the part of the codebase you are working on.

## 1. Understanding the Project

- **Familiarize Yourself:** Before making changes, try to understand the relevant parts of the project structure, including both the C# backend (ASP.NET Core, HotChocolate for GraphQL) and the TypeScript frontend (React, Vite, urql).
- **Ask Questions:** If the user's request is unclear or ambiguous, ask for clarification. It's better to ask than to make incorrect assumptions.

## 2. Code Style and Conventions

### General
- **Consistency:** Strive to maintain consistency with the existing codebase in terms of style, naming conventions, and architectural patterns.
- **Readability:** Write clear, concise, and well-documented code where necessary. Comment on non-obvious logic.
- **Modularity:** Create small, focused functions and components where appropriate.

### Frontend (React & TypeScript)
- **Functional Components:** Always use functional React components with Hooks.
- **TypeScript:** Utilize TypeScript's features for strong typing. Define interfaces or types for props, state, and API payloads.
- **Imports:** Use absolute paths with the `@/` alias (e.g., `@/features/...`) for imports within the `Web/src` directory.
- **File Naming:** Use PascalCase for component files (e.g., `MyComponent.tsx`).
- **Styling:** (User to specify preferred styling approach if any - e.g., CSS Modules, styled-components, Tailwind CSS). For now, inline styles are sometimes used for expediency, but consider maintainability.

### Backend (C# & ASP.NET Core)
- **Naming Conventions:** Follow standard C# naming conventions (e.g., PascalCase for classes, methods, properties).
- **Async/Await:** Use `async` and `await` for I/O-bound operations.
- **Dependency Injection:** Utilize ASP.NET Core's built-in dependency injection.
- **LINQ:** Use LINQ for data manipulation where appropriate.

## 3. GraphQL Usage (Frontend & Backend)

### Frontend (urql)
- **Queries/Mutations:**
    - Define GraphQL operations (queries, mutations, fragments) using the `graphql` tag from `@/gql` or preferably use the pre-compiled `...Document` constants generated by `graphql-codegen` (e.g., `import { MyQueryDocument } from '@/gql/graphql';`).
    - Place GraphQL operations in the relevant feature/component file or a dedicated `*.gql.ts` file if they become too numerous.
- **Generated Types:** Always use the TypeScript types generated by `graphql-codegen` (from `@/gql/graphql`) for query/mutation results and variables.
    - Example: `useQuery<MyQuery, MyQueryVariables>({ query: MyQueryDocument, ... });`
- **Colocation:** Keep GraphQL operations co-located with the components that use them, or within the same feature module.

### Backend (HotChocolate)
- **Schema-First vs. Code-First:** The project uses a code-first approach with HotChocolate. GraphQL types are generated from C# classes.
- **Naming:** HotChocolate typically converts C# method names to camelCase for GraphQL field names. Use `[GraphQLName("explicitName")]` if a different GraphQL field name is desired.
- **Type Extensions:** Extend the root `Query`, `Mutation`, or `Subscription` types by creating classes that use `[ExtendObjectType(typeof(Query))]`.
- **Registration:** Ensure new Query/Mutation/Subscription type extensions are registered in `Program.cs` (e.g., `.AddTypeExtension<MyNewQueries>()`).

## 4. State Management (Frontend)

- **Local State:** Use `useState` for component-local state.
- **Shared State:**
    - For simple shared state between a few components, consider prop drilling or React Context (`useContext`).
    - For more complex global state, (User to specify if a global state manager like Zustand, Redux, or Jotai is preferred or already in use). `urql` itself provides client-side caching for GraphQL data.
- **Derived State:** Use `useMemo` to memoize expensive calculations or derived data. `useCallback` for memoizing functions passed as props.

## 5. Error Handling

### Frontend
- **API Errors:** Catch errors from `urql` hooks (`result.error`) and display user-friendly messages or fallback UI.
- **Component Errors:** Use error boundaries for larger sections of the UI if applicable.
- **Input Validation:** Provide clear validation messages for user inputs.

### Backend
- **Exceptions:** Handle exceptions gracefully. Return appropriate GraphQL errors to the client.
- **Validation:** Use FluentValidation or similar for input DTOs in mutations/queries if complex validation is needed.

## 6. Backend Development

- **Migrations:** When changing database models (entities in `MusicGQL/Db/Postgres/Models/`), create new Entity Framework migrations:
    - `cd MusicGQL`
    - `dotnet ef migrations add MigrationName`
    - `dotnet ef database update`
- **Services:** Encapsulate business logic and interactions with external services or the database within service classes.
- **Event Sourcing:** The playlist database is event-sourced. Be mindful of existing events and create new ones as needed (`MusicGQL/Db/Postgres/Models/Events/`).

## 7. Tooling and Workflow

- **GraphQL Codegen:** After backend GraphQL schema changes, run `bun run types` in the `Web` directory to regenerate frontend types and documents. The backend server (`MusicGQL`) must be running and accessible (usually on `http://localhost:5095/graphql` as per `Web/codegen.ts`) for this to succeed.
- **Building & Running:**
    - **Backend:** `cd MusicGQL && dotnet build && dotnet run`
    - **Frontend:** `cd Web && bun install && bun dev`
- **Linting/Formatting:** (User to specify linters/formatters like ESLint, Prettier, and how to run them). Assume they are run automatically or via IDE integrations.

## 8. Testing

- (User to specify testing strategy, frameworks like Jest, Vitest, React Testing Library, xUnit, NUnit, and where tests are located).
- Strive to write testable code.

## 9. Commit Messages

- (User to specify preferred commit message format, e.g., Conventional Commits).
- As a general guideline: Write clear and concise commit messages that explain the "what" and "why" of the change.

## 10. Communication with User

- **Proactive Updates:** Keep the user informed about the plan, progress, and any issues encountered.
- **Confirmation:** Before making significant changes or if unsure, confirm the approach with the user.
- **Tool Usage Explanation:** Briefly explain why a tool is being used if it's not obvious.
- **Summaries:** Provide summaries of changes made, especially for larger tasks.

## 11. Recent Lessons (Do Not Repeat)

- Always convert new GraphQL mutations to use a single input object parameter, following the SignInMutation pattern.
  - Example: prefer `refreshRelease(input: RefreshReleaseInput!)` over `refreshRelease(artistId: String!, releaseFolderName: String!)`.
  - Backend: method signature should accept a C# input record/class, e.g., `public Task<RefreshReleaseResult> RefreshRelease(RefreshReleaseInput input, ...)`.
  - Frontend: call with `refreshRelease({ input: { artistId, releaseFolderName }})` and regenerate types (`bun run types:once`).

- After creating new GraphQL type extensions, register them in Program.cs.
  - Add `.AddTypeExtension<YourMutationClass>()` and explicitly add result types if needed.
  - Missing registration causes the operation to be absent from the runtime schema.

- When adding potentially destructive actions in the UI (e.g., deleting audio files), implement a confirmation dialog and extract it into a dedicated component for reuse and clarity.
  - Place components under a feature-appropriate folder (e.g., `Web/src/features/album/components/ConfirmDeleteReleaseAudioDialog.tsx`).

- When modifying release metadata or audio references, update only the affected release in the cache instead of rebuilding the entire cache.
  - Use `ServerLibraryCache.UpdateReleaseFromJsonAsync(artistId, releaseFolderName)` and preserve track-level statuses.

This is a starting point. Please feel free to update and expand these guidelines as the project evolves! 
