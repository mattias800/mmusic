"""
The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response.
"""
directive @cost(
  """
  The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc.
  """
  weight: String!
) on ARGUMENT_DEFINITION | ENUM | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | OBJECT | SCALAR

"""
The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information.
"""
directive @listSize(
  """
  The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field.
  """
  assumedSize: Int

  """
  The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error.
  """
  requireOneSlicingArgument: Boolean! = true

  """
  The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields.
  """
  sizedFields: [String!]

  """
  The `slicingArgumentDefaultValue` argument can be used to define a default value for a slicing argument, which is used if the argument is not present in a query.
  """
  slicingArgumentDefaultValue: Int

  """
  The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments.
  """
  slicingArguments: [String!]
) on FIELD_DEFINITION

type AddTrackToPlaylistError {
  message: String!
}

input AddTrackToPlaylistInput {
  artistId: ID!
  playlistId: ID!
  releaseFolderName: String!
  trackNumber: Int!
}

union AddTrackToPlaylistResult = AddTrackToPlaylistError | AddTrackToPlaylistSuccess

type AddTrackToPlaylistSuccess {
  playlist: Playlist!
}

"""Defines when a policy shall be executed."""
enum ApplyPolicy {
  """After the resolver was executed."""
  AFTER_RESOLVER

  """Before the resolver was executed."""
  BEFORE_RESOLVER

  """The policy is applied in the validation step before the execution."""
  VALIDATION
}

type Artist implements ArtistBase {
  albums: [Release!]!
  connectedExternalServices: [ArtistConnectedExternalService!]!
  eps: [Release!]!
  id: ID!
  images: ArtistImages
  listeners: Long
  name: String!
  releaseByFolderName(releaseFolderName: String!): Release
  releases: [Release!]!
  singles: [Release!]!
  sortName: String!
  topTracks: [ArtistTopTrack!]!
}

interface ArtistBase {
  id: ID!
  name: String!
  sortName: String!
}

type ArtistConnectedExternalService {
  artistPageUrl: String!
  externalArtistId: String
  externalService: ExternalService!
  isConnected: Boolean!
}

type ArtistImages {
  backgrounds: [String!]!
  banners: [String!]!
  logos: [String!]!
  thumbs: [String!]!
}

type ArtistImportHistoryItem {
  artistName: String!
  errorMessage: String
  jobKind: ArtistImportJobKind!
  localArtistId: String
  musicBrainzArtistId: String
  releaseFolderName: String
  songTitle: String
  success: Boolean!
  timestampUtc: DateTime!
}

enum ArtistImportJobKind {
  IMPORT_ARTIST
  REFRESH_RELEASE_METADATA
}

type ArtistImportProgress {
  artistName: String!
  completedReleases: Int!
  errorMessage: String
  id: String!
  songTitle: String
  status: ArtistImportStatus!
  statusInfo: ArtistImportStatusInfo!
  totalReleases: Int!
}

type ArtistImportQueueItem {
  artistName: String!
  id: String!
  jobKind: ArtistImportJobKind!
  localArtistId: String
  queueKey: String
  releaseFolderName: String
  songTitle: String
}

type ArtistImportQueueState {
  id: String!
  items: [ArtistImportQueueItem!]!
  queueLength: Int!
}

type ArtistImportSearchRoot {
  artistImportHistory: [ArtistImportHistoryItem!]!
  artistImportQueue: ArtistImportQueueState!
  currentArtistImport: ArtistImportProgress
}

enum ArtistImportStatus {
  COMPLETED
  FAILED
  IDLE
  IMPORTING_ARTIST
  IMPORTING_RELEASES
  RESOLVING_ARTIST
}

type ArtistImportStatusInfo {
  id: ArtistImportStatus!
  text: String!
}

type ArtistSearchRoot {
  all: [Artist!]!
  byId(artistId: ID!): Artist
  externalArtistById(artistId: ID!, serviceType: ExternalServiceType!): ExternalArtist
  searchArtists(limit: Int! = 20, searchTerm: String!): [Artist!]!
  searchExternalArtists(limit: Int! = 10, searchTerm: String!, serviceType: ExternalServiceType!): [ExternalArtist!]!
}

type ArtistTopTrack {
  coverArtUrl: String
  playCount: Long
  releaseTitle: String
  title: String!
  track: Track
  trackLength: Int
}

enum BulkDownloadScope {
  ALBUMS
  ALL
  EPS
  SINGLES
}

type CacheStatistics {
  artistCount: Int!
  isInitialized: Boolean!
  lastUpdated: DateTime!
  releaseCount: Int!
  trackCount: Int!
}

type CreateDirectoryError {
  message: String!
}

input CreateDirectoryInput {
  path: String!
}

union CreateDirectoryResult = CreateDirectoryError | CreateDirectorySuccess

type CreateDirectorySuccess {
  entry: FileSystemEntry!
}

input CreatePlaylistInput {
  description: String
  name: String
}

union CreatePlaylistResult = CreatePlaylistSuccess

type CreatePlaylistSuccess {
  playlist: Playlist!
}

type CreateUserError {
  message: String!
}

input CreateUserInput {
  password: String!
  username: String!
}

union CreateUserResult = CreateUserError | CreateUserSuccess

type CreateUserSuccess {
  user: User!
}

"""The `DateTime` scalar represents an ISO-8601 compliant date time type."""
scalar DateTime

input DeletePlaylistInput {
  playlistId: ID!
}

type DeletePlaylistNoWriteAccess {
  message: String!
}

union DeletePlaylistResult = DeletePlaylistNoWriteAccess | DeletePlaylistSuccess

type DeletePlaylistSuccess {
  deletedPlaylistId: UUID!
}

type DeleteReleaseAudioError {
  message: String!
}

input DeleteReleaseAudioInput {
  artistId: String!
  releaseFolderName: String!
}

union DeleteReleaseAudioResult = DeleteReleaseAudioError | DeleteReleaseAudioSuccess

type DeleteReleaseAudioSuccess {
  release: Release!
}

type DownloadHistoryItem {
  artistId: String!
  artistName: String
  errorMessage: String
  releaseFolderName: String!
  releaseTitle: String
  success: Boolean!
  timestampUtc: DateTime!
}

type DownloadProgress {
  artistId: String!
  artistName: String
  completedTracks: Int!
  coverArtUrl: String
  currentDownloadSpeedKbps: Float
  currentTrackProgressPercent: Float
  errorMessage: String
  id: String!
  releaseFolderName: String!
  releaseTitle: String
  status: DownloadStatus!
  totalTracks: Int!
}

type DownloadQueueItem {
  artistId: String!
  id: String!
  queueKey: String
  releaseFolderName: String!
}

type DownloadQueueState {
  id: String!
  items: [DownloadQueueItem!]!
  queueLength: Int!
}

enum DownloadStatus {
  COMPLETED
  DOWNLOADING
  FAILED
  IDLE
  PROCESSING
  SEARCHING
}

type DownloadsSearchRoot {
  currentDownload: DownloadProgress
  downloadHistory: [DownloadHistoryItem!]!
  downloadQueue: DownloadQueueState!
}

input EnqueueArtistsFromSpotifyPlaylistInput {
  playlistId: String!
}

type ExternalArtist {
  artistId: String!
  artistName: String!
  id: ID!
  service: ExternalServiceType!
}

type ExternalRoot {
  id: ID!
  soulSeek: SoulSeekRoot!
}

type ExternalService {
  id: ID!
  name: String!
}

enum ExternalServiceType {
  APPLE_MUSIC
  DEEZER
  OTHER
  SPOTIFY
  TIDAL
  YOU_TUBE_MUSIC
}

type ExternalServicesSearchRoot {
  all: [ExternalService!]!
  byId(id: ID!): ExternalService
}

type FileSystemEntry {
  hasChildren: Boolean!
  id: ID!
  isAccessible: Boolean!
  isDirectory: Boolean!
  name: String!
  path: String!
}

type FileSystemSearchRoot {
  browseFileSystem(path: String): [FileSystemEntry!]!
}

type ImportArtistError {
  message: String!
}

input ImportArtistInput {
  musicBrainzArtistId: String!
}

union ImportArtistResult = ImportArtistError | ImportArtistSuccess

type ImportArtistSuccess {
  artist: Artist!
}

type ImportArtistsFromSpotifyPlaylistError {
  message: String!
}

input ImportArtistsFromSpotifyPlaylistInput {
  playlistId: String!
}

union ImportArtistsFromSpotifyPlaylistResult = ImportArtistsFromSpotifyPlaylistError | ImportArtistsFromSpotifyPlaylistSuccess

type ImportArtistsFromSpotifyPlaylistSuccess {
  artists: [Artist!]!
  failedArtists: [String!]!
  importedArtists: Int!
  totalArtists: Int!
}

type ImportPlaylistSearchRoot {
  spotify: SpotifyPlaylistSearchRoot!
}

type ImportReleasesResult {
  artistId: String!
  errorMessage: String
  failedReleases: Int!
  importedReleases: [ImportedRelease!]!
  success: Boolean!
  successfulReleases: Int!
  totalReleases: Int!
}

type ImportSpotifyPlaylistError {
  message: String!
}

input ImportSpotifyPlaylistInput {
  playlistId: String!
  userId: UUID!
}

union ImportSpotifyPlaylistResult = ImportSpotifyPlaylistError | ImportSpotifyPlaylistSuccess

type ImportSpotifyPlaylistSuccess {
  playlist: Playlist!
}

type ImportedRelease {
  errorMessage: String
  releaseGroupId: String!
  success: Boolean!
  title: String!
}

type LastFmAlbum {
  album: MbReleaseGroup
  id: ID!
  imageUrl: String
  mbid: String!
  name: String!
  statistics: LastFmStatistics!
}

type LastFmArtist {
  artist: Artist
  id: ID!
  images: ArtistImages
  musicBrainzArtist: MbArtist
  name: String!
  statistics: LastFmStatistics!
  summary: String
  topTracks: [LastFmTrack!]!
}

type LastFmStatistics {
  listeners: Long!
  playCount: Long!
}

type LastFmTag {
  name: String!
  url: String!
}

type LastFmTrack {
  album: LastFmAlbum
  artist: LastFmArtist!
  id: ID!
  images: ArtistImages
  mbid: String
  musicBrainzRecording: MbRecording
  name: String!
  playCount: Long
  recording: Track
  statistics: LastFmStatistics!
  summary: String
}

type LibraryCacheTrackStatus {
  artistId: String!
  releaseFolderName: String!
  track: Track
  trackNumber: Int!
}

type LibraryReleaseDownloadStatusUpdate {
  release: Release!
}

type LikeSongAlreadyLiked {
  message: String!
}

input LikeSongInput {
  recordingId: String!
}

union LikeSongResult = LikeSongAlreadyLiked | LikeSongSongDoesNotExist | LikeSongSuccess

type LikeSongSongDoesNotExist {
  message: String!
}

type LikeSongSuccess {
  viewer: User!
}

type LikedSong {
  id: ID!
  recording: MbRecording
}

"""
The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type MbAlbumImages {
  albumCover: String
  cdArt: String
}

type MbArtist implements ArtistBase {
  albums: [MbReleaseGroup!]!
  country: String
  disambiguation: String
  id: ID!
  images: MbArtistImages
  lastFmArtist: LastFmArtist
  listeners: Long
  name: String!
  relations: [MbRelation!]!
  releaseGroups: [MbReleaseGroup!]!
  releases: [MbRelease!]!
  singles: [MbReleaseGroup!]!
  sortName: String!
  topTracks: [LastFmTrack!]!
  type: String
}

type MbArtistImages {
  artistBackground: String
  artistThumb: String
  hdMusicLogo: String
  musicBanner: String
  musicLogo: String
}

type MbGenre {
  id: ID!
  name: String!
}

type MbLabel {
  disambiguation: String
  id: String!
  name: String!
}

type MbLabelInfo {
  catalogNumber: String
  label: MbLabel!
}

type MbMedium {
  trackCount: Int!
  tracks: [MbTrack!]!
}

type MbNameCredit {
  artist: MbArtist!
  joinPhrase: String
  name: String!
}

type MbRecording {
  artists: [MbArtist!]!
  id: ID!
  length: Int
  mainAlbum: MbRelease
  nameCredits: [MbNameCredit!]!
  relations: [MbRelation!]!
  releases: [MbRelease!]!
  statistics: LastFmStatistics
  streamingServiceInfo: MbRecordingStreamingServiceInfo!
  title: String!
}

type MbRecordingStreamingServiceInfo {
  id: ID!
  youtubeMusicUrl: String
  youtubeSearchVideoId: String
  youtubeVideoId: String
}

type MbRelation {
  attributes: [String!]
  begin: String
  direction: String
  end: String
  targetType: String
  type: String
  typeId: String
  url: Url
}

type MbRelease {
  artists: [MbArtist!]!
  barcode: String
  country: String
  coverArtUri: String!
  credits: [MbNameCredit!]!
  date: String
  genres: [MbGenre!]!
  id: ID!
  labels: [MbLabelInfo!]!
  media: [MbMedium!]!
  quality: String
  recordings: [MbRecording!]!
  releaseGroup: MbReleaseGroup
  status: String
  title: String!
  year: String
}

type MbReleaseGroup {
  coverArtUri: String
  credits: [MbNameCredit!]!
  firstReleaseDate: String
  firstReleaseYear: String
  id: ID!
  images: MbAlbumImages
  mainRelease: MbRelease
  primaryType: String
  relations: [MbRelation!]!
  secondaryTypes: [String!]!
  tags: [String!]!
  title: String!
}

type MbTrack {
  id: ID!
  mbRecording: MbRecording!
  position: Int!
}

enum MediaAvailabilityStatus {
  AVAILABLE
  DOWNLOADING
  MISSING
  PROCESSING
  QUEUED_FOR_DOWNLOAD
  UNKNOWN
}

type MovePlaylistItemError {
  message: String!
}

input MovePlaylistItemInput {
  newIndex: Int!
  playlistId: ID!
  playlistItemId: ID!
}

union MovePlaylistItemResult = MovePlaylistItemError | MovePlaylistItemSuccess

type MovePlaylistItemSuccess {
  playlist: Playlist!
}

type MusicBrainzArtistSearchRoot {
  byId(id: ID!): MbArtist
  searchByName(limit: Int! = 25, name: String!, offset: Int! = 0): [MbArtist!]!
}

type MusicBrainzRecordingSearchRoot {
  byId(id: ID!): MbRecording
  searchByName(limit: Int! = 25, name: String!, offset: Int! = 0): [MbRecording!]!
}

type MusicBrainzReleaseGroupSearchRoot {
  byId(id: ID!): MbReleaseGroup
  searchByName(limit: Int! = 25, name: String!, offset: Int! = 0): [MbReleaseGroup!]!
  searchByNameAndArtistName(artistName: String!, limit: Int! = 25, name: String!, offset: Int! = 0): [MbReleaseGroup!]!
}

type MusicBrainzReleaseSearchRoot {
  byId(id: ID!): MbRelease
  searchByName(limit: Int! = 25, name: String!, offset: Int! = 0): [MbRelease!]!
}

type MusicBrainzSearchRoot {
  artist: MusicBrainzArtistSearchRoot!
  recording: MusicBrainzRecordingSearchRoot!
  release: MusicBrainzReleaseSearchRoot!
  releaseGroup: MusicBrainzReleaseGroupSearchRoot!
}

type Mutation {
  addTrackToPlaylist(input: AddTrackToPlaylistInput!): AddTrackToPlaylistResult!
  createDirectory(input: CreateDirectoryInput!): CreateDirectoryResult!
  createPlaylist(input: CreatePlaylistInput!): CreatePlaylistResult!
  createUser(input: CreateUserInput!): CreateUserResult!
  deletePlaylist(input: DeletePlaylistInput!): DeletePlaylistResult!
  deleteReleaseAudio(input: DeleteReleaseAudioInput!): DeleteReleaseAudioResult!
  enqueueArtist(artistName: String!, songTitle: String): Boolean!
  enqueueArtistsFromSpotifyPlaylist(input: EnqueueArtistsFromSpotifyPlaylistInput!): Boolean!
  enqueueMissingArtistsFromPlaylist(playlistId: ID!): Boolean!
  importArtist(input: ImportArtistInput!): ImportArtistResult!
  importArtistReleases(artistId: String!): ImportReleasesResult!
  importArtistsFromSpotifyPlaylist(input: ImportArtistsFromSpotifyPlaylistInput!): ImportArtistsFromSpotifyPlaylistResult!
  importSpotifyPlaylist(input: ImportSpotifyPlaylistInput!): ImportSpotifyPlaylistResult!
  likeSong(input: LikeSongInput!): LikeSongResult!
  movePlaylistItem(input: MovePlaylistItemInput!): MovePlaylistItemResult!
  ping: Boolean!
  redownloadRelease(input: RedownloadReleaseInput!): RedownloadReleaseResult!
  refreshAllReleasesForArtist(artistId: String!): RefreshAllReleasesForArtistResult!
  refreshArtistMetaData(input: RefreshArtistMetaDataInput!): RefreshArtistMetaDataResult!
  refreshArtistTopTracks(input: RefreshArtistTopTracksInput!): RefreshArtistTopTracksResult!
  refreshRelease(input: RefreshReleaseInput!): RefreshReleaseResult!
  removeArtistImportJob(queueKey: String!): Boolean!
  removeDownloadJob(queueKey: String!): Boolean!
  removeItemFromPlaylist(input: RemoveItemFromPlaylistInput!): RemoveItemFromPlaylistResult!
  renamePlaylist(input: RenamePlaylistInput!): RenamePlaylistResult!
  scanLibraryForMissingJson: ScanLibraryForMissingJsonResult!
  scanReleaseFolderForMedia(input: ScanReleaseFolderForMediaInput!): ScanReleaseFolderForMediaResult!
  setArtistMusicBrainzMatch(input: SetArtistMusicBrainzMatchInput!): SetArtistMusicBrainzMatchResult!
  setArtistSpotifyMatch(input: SetArtistSpotifyMatchInput!): SetArtistSpotifyMatchResult!
  setPlaylistItemArtistMatch(input: SetPlaylistItemArtistMatchInput!): SetPlaylistItemArtistMatchResult!
  setPlaylistItemArtistMusicBrainzMatch(input: SetPlaylistItemArtistMusicBrainzMatchInput!): SetPlaylistItemArtistMusicBrainzMatchResult!
  setReleaseGroup(input: SetReleaseGroupInput!): SetReleaseGroupResult!
  setReleaseMatchOverride(input: SetReleaseMatchOverrideInput!): SetReleaseMatchOverrideResult!
  signIn(input: SignInInput!): SignInResult!
  signOut(input: SignOutInput!): SignOutResult!
  startBulkDownloadForArtist(input: StartBulkDownloadForArtistInput!): StartBulkDownloadForArtistResult!
  startDownloadRelease(input: StartDownloadReleaseInput!): StartDownloadReleaseResult!
  unlikeSong(input: UnlikedSongInput!): UnlikeSongResult!
  updateDownloadPath(input: UpdateDownloadPathInput!): UpdateDownloadPathResult!
  updateLibraryPath(input: UpdateLibraryPathInput!): UpdateLibraryPathResult!
  updateSoulSeekSearchTimeLimit(seconds: Int!): UpdateSoulSeekSearchTimeLimitResult!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """
  Indicates whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more edges exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type Ping {
  id: ID!
}

type Playlist {
  coverImageUrl: String
  createdAt: DateTime!
  id: ID!
  items: [PlaylistItem!]!
  modifiedAt: DateTime
  name: String
}

type PlaylistItem {
  addedAt: DateTime!
  artist: Artist
  artistName: String
  coverImageUrl: String
  externalAlbumId: String
  externalArtistId: String
  externalService: ExternalServiceType
  externalTrackId: String
  id: ID!
  localCoverImageUrl: String
  releaseTitle: String
  releaseType: String
  title: String
  track: Track
  trackLengthMs: Int
}

type PlaylistSearchRoot {
  byId(playlistId: ID!): Playlist
  importPlaylists: ImportPlaylistSearchRoot!
}

type Query {
  areThereAnyUsers: Boolean!
  artist: ArtistSearchRoot!
  artistImport: ArtistImportSearchRoot!
  downloads: DownloadsSearchRoot!
  external: ExternalRoot!
  externalServices: ExternalServicesSearchRoot!
  fileSystem: FileSystemSearchRoot!
  musicBrainz: MusicBrainzSearchRoot!
  playlist: PlaylistSearchRoot!
  recommendations: RecommendationsSearchRoot!
  releasesWithScores(artistId: String!, releaseFolderName: String!, releaseGroupId: String!): [ScoredRelease!]!
  serverLibrary: ServerLibrarySearchRoot!
  serverSettings: ServerSettings!
  spotify: SpotifyArtistSearchRoot!
  user: UserSearchRoot!
  viewer: User
}

type RecommendationsSearchRoot {
  topArtists: [LastFmArtist!]!
  topTags: [LastFmTag!]!
  topTracks: [LastFmTrack!]!
}

type RedownloadReleaseError {
  message: String!
}

input RedownloadReleaseInput {
  artistId: String!
  releaseFolderName: String!
}

union RedownloadReleaseResult = RedownloadReleaseError | RedownloadReleaseSuccess

type RedownloadReleaseSuccess {
  release: Release!
}

type RefreshAllReleasesForArtistError {
  message: String!
}

union RefreshAllReleasesForArtistResult = RefreshAllReleasesForArtistError | RefreshAllReleasesForArtistSuccess

type RefreshAllReleasesForArtistSuccess {
  artistId: String!
  refreshedCount: Int!
}

type RefreshArtistMetaDataError {
  message: String!
}

input RefreshArtistMetaDataInput {
  artistId: String!
}

union RefreshArtistMetaDataResult = RefreshArtistMetaDataError | RefreshArtistMetaDataSuccess

type RefreshArtistMetaDataSuccess {
  artist: Artist!
}

input RefreshArtistTopTracksInput {
  artistId: String!
}

union RefreshArtistTopTracksResult = RefreshArtistTopTracksSuccess | RefreshArtistTopTracksUnknownError

type RefreshArtistTopTracksSuccess {
  artist: Artist!
}

type RefreshArtistTopTracksUnknownError {
  message: String!
}

type RefreshReleaseError {
  message: String!
}

input RefreshReleaseInput {
  artistId: String!
  releaseFolderName: String!
}

union RefreshReleaseResult = RefreshReleaseError | RefreshReleaseSuccess

type RefreshReleaseSuccess {
  release: Release!
}

type Release {
  artist: Artist!
  coverArtUrl: String!
  downloadStatus: ReleaseDownloadStatus!
  firstReleaseDate: String
  firstReleaseYear: String
  folderName: String!
  id: ID!
  isFullyMissing: Boolean!
  musicBrainzReleaseGroupId: String
  musicBrainzReleaseIdOverride: String
  musicBrainzSelectedReleaseId: String
  title: String!
  tracks: [Track!]!
  type: ReleaseType
}

enum ReleaseDownloadStatus {
  DOWNLOADING
  IDLE
  NOT_FOUND
  SEARCHING
}

enum ReleaseType {
  ALBUM
  EP
  SINGLE
}

type RemoveItemFromPlaylistError {
  message: String!
}

input RemoveItemFromPlaylistInput {
  playlistId: ID!
  playlistItemId: ID!
}

union RemoveItemFromPlaylistResult = RemoveItemFromPlaylistError | RemoveItemFromPlaylistSuccess

type RemoveItemFromPlaylistSuccess {
  playlist: Playlist!
}

input RenamePlaylistInput {
  newPlaylistName: String!
  playlistId: ID!
}

type RenamePlaylistNoWriteAccess {
  message: String!
}

union RenamePlaylistResult = RenamePlaylistNoWriteAccess | RenamePlaylistSuccess

type RenamePlaylistSuccess {
  playlist: Playlist!
}

union ScanLibraryForMissingJsonResult = ScanLibraryForMissingJsonSuccess

type ScanLibraryForMissingJsonSuccess {
  artistsCreated: Int!
  errorMessage: String
  notes: [String!]!
  releasesCreated: Int!
  success: Boolean!
}

type ScanReleaseFolderForMediaError {
  message: String!
}

input ScanReleaseFolderForMediaInput {
  artistId: String!
  releaseFolderName: String!
}

union ScanReleaseFolderForMediaResult = ScanReleaseFolderForMediaError | ScanReleaseFolderForMediaSuccess

type ScanReleaseFolderForMediaSuccess {
  release: Release!
}

type ScoredRelease {
  reasons: [String!]!
  release: MbRelease!
  score: Int!
}

type ServerLibrarySearchRoot {
  allArtists: [Artist!]!
  allReleases: [Release!]!
  allTracks: [Track!]!
  artistById(id: ID!): Artist
  libraryStatistics: CacheStatistics!
  releaseForArtistByFolderName(artistId: ID!, releaseFolderName: String!): Release
  releasesForArtist(artistId: ID!): [Release!]!
  searchArtists(limit: Int! = 20, searchTerm: String!): [Artist!]!
  searchReleases(limit: Int! = 20, searchTerm: String!): [Release!]!
  searchTracks(limit: Int! = 20, searchTerm: String!): [Track!]!
  trackById(id: ID!): Track
  tracksForArtist(artistId: ID!): [Track!]!
}

type ServerSettings {
  downloadPath: String!
  id: ID!
  libraryPath: String!
  soulSeekNoDataTimeoutSeconds: Int!
  soulSeekSearchTimeLimitSeconds: Int!
}

type SetArtistMusicBrainzMatchError {
  message: String!
}

input SetArtistMusicBrainzMatchInput {
  artistId: String!
  musicBrainzArtistId: String!
}

union SetArtistMusicBrainzMatchResult = SetArtistMusicBrainzMatchError | SetArtistMusicBrainzMatchSuccess

type SetArtistMusicBrainzMatchSuccess {
  artist: Artist!
}

type SetArtistSpotifyMatchError {
  message: String!
}

input SetArtistSpotifyMatchInput {
  artistId: String!
  spotifyArtistId: String!
}

union SetArtistSpotifyMatchResult = SetArtistSpotifyMatchError | SetArtistSpotifyMatchSuccess

type SetArtistSpotifyMatchSuccess {
  artist: Artist!
}

input SetPlaylistItemArtistMatchInput {
  externalArtistId: String!
  playlistId: ID!
  playlistItemId: ID!
}

type SetPlaylistItemArtistMatchNotFound {
  message: String!
}

union SetPlaylistItemArtistMatchResult = SetPlaylistItemArtistMatchNotFound | SetPlaylistItemArtistMatchSuccess

type SetPlaylistItemArtistMatchSuccess {
  playlistItem: PlaylistItem!
}

type SetPlaylistItemArtistMusicBrainzMatchError {
  message: String!
}

input SetPlaylistItemArtistMusicBrainzMatchInput {
  musicBrainzArtistId: String!
  playlistId: ID!
  playlistItemId: ID!
}

type SetPlaylistItemArtistMusicBrainzMatchNotFound {
  message: String!
}

union SetPlaylistItemArtistMusicBrainzMatchResult = SetPlaylistItemArtistMusicBrainzMatchError | SetPlaylistItemArtistMusicBrainzMatchNotFound | SetPlaylistItemArtistMusicBrainzMatchSuccess

type SetPlaylistItemArtistMusicBrainzMatchSuccess {
  playlistItem: PlaylistItem!
}

type SetReleaseGroupError {
  message: String!
}

input SetReleaseGroupInput {
  artistId: String!
  musicBrainzReleaseGroupId: String!
  releaseFolderName: String!
}

union SetReleaseGroupResult = SetReleaseGroupError | SetReleaseGroupSuccess

type SetReleaseGroupSuccess {
  release: Release!
}

type SetReleaseMatchOverrideError {
  message: String!
}

input SetReleaseMatchOverrideInput {
  artistId: String!
  musicBrainzReleaseId: String
  releaseFolderName: String!
}

union SetReleaseMatchOverrideResult = SetReleaseMatchOverrideError | SetReleaseMatchOverrideSuccess

type SetReleaseMatchOverrideSuccess {
  release: Release!
}

type SignInError {
  message: String!
}

input SignInInput {
  password: String!
  username: String!
}

union SignInResult = SignInError | SignInSuccess

type SignInSuccess {
  user: User!
}

type SignOutError {
  message: String!
}

input SignOutInput {
  confirm: Boolean!
}

union SignOutResult = SignOutError | SignOutSuccess

type SignOutSuccess {
  success: Boolean!
}

type SoulSeekRoot {
  id: ID!
  status: SoulSeekStatus!
}

type SoulSeekStatus {
  id: ID!
  status: SoulSeekStatusType!
}

enum SoulSeekStatusType {
  CONNECTING
  OFFLINE
  ONLINE
}

type SpotifyArtist {
  id: String!
  images: [SpotifyImage!]!
  name: String!
}

type SpotifyArtistSearchRoot {
  byId(id: ID!): SpotifyArtist
  searchByName(limit: Int! = 25, name: String!, offset: Int! = 0): [SpotifyArtist!]!
}

type SpotifyImage {
  url: String!
}

type SpotifyPlaylist {
  coverImageUrl: String
  description: String
  id: String!
  name: String!
  totalTracks: Int
  tracks: [SpotifyTrack!]!
}

type SpotifyPlaylistSearchRoot {
  spotifyPlaylistById(id: String!): SpotifyPlaylist
  spotifyPlaylistsForUser(username: String!): [SpotifyPlaylist!]!
}

type SpotifyTrack {
  albumCoverImageUrl: String
  artistNames: [String!]!
  durationMs: Int
  id: String!
  previewUrl: String
  title: String!
}

type StartBulkDownloadForArtistError {
  message: String!
}

input StartBulkDownloadForArtistInput {
  artistId: String!
  scope: BulkDownloadScope!
}

union StartBulkDownloadForArtistResult = StartBulkDownloadForArtistError | StartBulkDownloadForArtistSuccess

type StartBulkDownloadForArtistSuccess {
  artistId: String!
  queuedCount: Int!
}

type StartDownloadReleaseAccepted {
  artistId: String!
  releaseFolderName: String!
}

input StartDownloadReleaseInput {
  artistId: String!
  releaseFolderName: String!
}

union StartDownloadReleaseResult = StartDownloadReleaseAccepted | StartDownloadReleaseSuccess | StartDownloadReleaseUnknownError

type StartDownloadReleaseSuccess {
  release: Release!
}

type StartDownloadReleaseUnknownError {
  message: String!
}

type Subscription {
  artistImportQueueUpdated: ArtistImportQueueState!
  artistImported: Artist!
  currentArtistImportUpdated: ArtistImportProgress!
  currentDownloadUpdated: DownloadProgress
  downloadHistoryUpdated: [DownloadHistoryItem!]!
  downloadQueueUpdated: DownloadQueueState!
  libraryArtistReleaseUpdated(artistId: String!): Release!
  libraryArtistTrackUpdated(artistId: String!): Track!
  libraryArtistUpdated(artistId: String!): Artist!
  libraryCacheTrackUpdated(artistId: String!, releaseFolderName: String!, trackNumber: Int!): LibraryCacheTrackStatus!
  libraryCacheTracksInReleaseUpdated(artistId: String!, releaseFolderName: String!): LibraryCacheTrackStatus!
  libraryReleaseDownloadStatusUpdated(artistId: String!, releaseFolderName: String!): LibraryReleaseDownloadStatusUpdate!
  libraryReleaseMetadataUpdated(artistId: String!, releaseFolderName: String!): Release!
  libraryReleaseUpdated(artistId: String!, releaseFolderName: String!): Release!
  libraryTrackUpdated(artistId: String!, releaseFolderName: String!, trackNumber: Int!): Track!
  ping: Ping!
  playlistItemUpdated(playlistId: ID!): PlaylistItem!
  soulSeekStatusUpdated: SoulSeekStatus!
}

type Track {
  credits: [TrackCredit!]!
  id: ID!
  isMissing: Boolean!
  media: TrackMedia
  mediaAvailabilityStatus: MediaAvailabilityStatus!
  playCount: Long
  playCountForViewer: Long
  release: Release!
  statistics: TrackStatistics
  title: String!
  trackLength: Int
  trackNumber: Int!
}

type TrackCredit {
  artist: Artist
  artistName: String!
  mbArtist: MbArtist
}

type TrackMedia {
  audioBitrateKbps: Int
  audioFormat: String
  audioQualityLabel: String!
  audioUrl: String!
  id: ID!
  isLosslessFormat: Boolean!
}

type TrackStatistics {
  listeners: Long!
  playCount: Long!
}

scalar UUID

type UnlikeSongAlreadyNotLiked {
  message: String!
}

union UnlikeSongResult = UnlikeSongAlreadyNotLiked | UnlikeSongSuccess

type UnlikeSongSuccess {
  viewer: User!
}

input UnlikedSongInput {
  recordingId: String!
}

input UpdateDownloadPathInput {
  newDownloadPath: String!
}

union UpdateDownloadPathResult = UpdateDownloadPathSuccess

type UpdateDownloadPathSuccess {
  serverSettings: ServerSettings!
}

input UpdateLibraryPathInput {
  newLibraryPath: String!
}

union UpdateLibraryPathResult = UpdateLibraryPathSuccess

type UpdateLibraryPathSuccess {
  serverSettings: ServerSettings!
}

type UpdateSoulSeekSearchTimeLimitError {
  message: String!
}

union UpdateSoulSeekSearchTimeLimitResult = UpdateSoulSeekSearchTimeLimitError | UpdateSoulSeekSearchTimeLimitSuccess

type UpdateSoulSeekSearchTimeLimitSuccess {
  serverSettings: ServerSettings!
}

type Url {
  id: String
  resource: String
}

type User {
  createdAt: DateTime!
  id: ID!
  likedSongs: [LikedSong!]!
  playlists: [Playlist!]!
  updatedAt: DateTime!
  username: String!
}

type UserSearchRoot {
  users(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): UsersConnection
}

"""A connection to a list of items."""
type UsersConnection {
  """A list of edges."""
  edges: [UsersEdge!]

  """A flattened list of the nodes."""
  nodes: [User!]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: User!
}